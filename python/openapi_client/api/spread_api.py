# coding: utf-8

"""
    P6 EPPM Rest API

    The Primavera P6 Enterprise Project Portfolio Management (P6 EPPM) API is a flexible interface to P6 EPPM functionality based on the Representational State Transfer (REST) architectural style. Clients can use HTTP enabled technologies to interact with the API and access application features. For example, you can write programs in Javascript, Java, and other languages to create users, view a list of users, update a user's status, or update user details.

    The version of the OpenAPI document: 2022.12.12
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from openapi_client.models.read_activity_spread_response import ReadActivitySpreadResponse
from openapi_client.models.read_cbs_expense_spread_response import ReadCBSExpenseSpreadResponse
from openapi_client.models.read_cbs_resource_spread_response import ReadCBSResourceSpreadResponse
from openapi_client.models.read_eps_spread_response import ReadEPSSpreadResponse
from openapi_client.models.read_project_resource_spread_response import ReadProjectResourceSpreadResponse
from openapi_client.models.read_project_role_spread_response import ReadProjectRoleSpreadResponse
from openapi_client.models.read_project_spread_response import ReadProjectSpreadResponse
from openapi_client.models.read_resource_assignment_spread_response import ReadResourceAssignmentSpreadResponse
from openapi_client.models.read_wbs_expense_spread_response import ReadWBSExpenseSpreadResponse
from openapi_client.models.read_wbs_resource_spread_response import ReadWBSResourceSpreadResponse
from openapi_client.models.read_wbs_role_spread_response import ReadWBSRoleSpreadResponse
from openapi_client.models.read_wbs_spread_response import ReadWBSSpreadResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class SpreadApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def read_activity_spread(
        self,
        activity_object_id: Annotated[StrictStr, Field(description="ActivityObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadActivitySpreadResponse]:
        """ReadActivitySpread

        Reads the live activity spread data from the specified activities.

        :param activity_object_id: ActivityObjectId's to load (required)
        :type activity_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_activity_spread_serialize(
            activity_object_id=activity_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadActivitySpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_activity_spread_with_http_info(
        self,
        activity_object_id: Annotated[StrictStr, Field(description="ActivityObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadActivitySpreadResponse]]:
        """ReadActivitySpread

        Reads the live activity spread data from the specified activities.

        :param activity_object_id: ActivityObjectId's to load (required)
        :type activity_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_activity_spread_serialize(
            activity_object_id=activity_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadActivitySpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_activity_spread_without_preload_content(
        self,
        activity_object_id: Annotated[StrictStr, Field(description="ActivityObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadActivitySpread

        Reads the live activity spread data from the specified activities.

        :param activity_object_id: ActivityObjectId's to load (required)
        :type activity_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_activity_spread_serialize(
            activity_object_id=activity_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadActivitySpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_activity_spread_serialize(
        self,
        activity_object_id,
        period_type,
        spread_field,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if activity_object_id is not None:
            
            _query_params.append(('ActivityObjectId', activity_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/activitySpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_cbs_resource_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadCBSExpenseSpreadResponse]:
        """ReadCBSExpenseSpread

        Reads the summarized CBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_cbs_resource_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadCBSExpenseSpreadResponse]]:
        """ReadCBSExpenseSpread

        Reads the summarized CBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_cbs_resource_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadCBSExpenseSpread

        Reads the summarized CBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_cbs_resource_spread_serialize(
        self,
        spread_field,
        project_object_id,
        baseline_ids,
        period_type,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_object_id is not None:
            
            _query_params.append(('ProjectObjectId', project_object_id))
            
        if baseline_ids is not None:
            
            _query_params.append(('BaselineIds', baseline_ids))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/cbsExpenseSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_cbs_resource_spread1(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        summary_date_field: Annotated[Optional[StrictStr], Field(description="SummaryDateField")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadCBSResourceSpreadResponse]:
        """ReadCBSResourceSpread

        Reads the summarized CBS spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param summary_date_field: SummaryDateField
        :type summary_date_field: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread1_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            summary_date_field=summary_date_field,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_cbs_resource_spread1_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        summary_date_field: Annotated[Optional[StrictStr], Field(description="SummaryDateField")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadCBSResourceSpreadResponse]]:
        """ReadCBSResourceSpread

        Reads the summarized CBS spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param summary_date_field: SummaryDateField
        :type summary_date_field: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread1_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            summary_date_field=summary_date_field,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_cbs_resource_spread1_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        baseline_ids: Annotated[Optional[StrictStr], Field(description="BaselineIds's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        summary_date_field: Annotated[Optional[StrictStr], Field(description="SummaryDateField")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadCBSResourceSpread

        Reads the summarized CBS spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param baseline_ids: BaselineIds's to load
        :type baseline_ids: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param summary_date_field: SummaryDateField
        :type summary_date_field: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_cbs_resource_spread1_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            baseline_ids=baseline_ids,
            period_type=period_type,
            summary_date_field=summary_date_field,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadCBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_cbs_resource_spread1_serialize(
        self,
        spread_field,
        project_object_id,
        baseline_ids,
        period_type,
        summary_date_field,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_object_id is not None:
            
            _query_params.append(('ProjectObjectId', project_object_id))
            
        if baseline_ids is not None:
            
            _query_params.append(('BaselineIds', baseline_ids))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if summary_date_field is not None:
            
            _query_params.append(('SummaryDateField', summary_date_field))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/cbsResourceSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_eps_spread(
        self,
        eps_object_id: Annotated[StrictStr, Field(description="EPSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadEPSSpreadResponse]:
        """ReadEPSSpread

        Reads the summarized spread data from the specified EPS objects.

        :param eps_object_id: EPSObjectId's to load (required)
        :type eps_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_eps_spread_serialize(
            eps_object_id=eps_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadEPSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_eps_spread_with_http_info(
        self,
        eps_object_id: Annotated[StrictStr, Field(description="EPSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadEPSSpreadResponse]]:
        """ReadEPSSpread

        Reads the summarized spread data from the specified EPS objects.

        :param eps_object_id: EPSObjectId's to load (required)
        :type eps_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_eps_spread_serialize(
            eps_object_id=eps_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadEPSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_eps_spread_without_preload_content(
        self,
        eps_object_id: Annotated[StrictStr, Field(description="EPSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadEPSSpread

        Reads the summarized spread data from the specified EPS objects.

        :param eps_object_id: EPSObjectId's to load (required)
        :type eps_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_eps_spread_serialize(
            eps_object_id=eps_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadEPSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_eps_spread_serialize(
        self,
        eps_object_id,
        period_type,
        spread_field,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if eps_object_id is not None:
            
            _query_params.append(('EPSObjectId', eps_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/epsSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_project_resource_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadProjectResourceSpreadResponse]:
        """ReadProjectResourceSpread

        Reads the summarized spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_project_resource_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadProjectResourceSpreadResponse]]:
        """ReadProjectResourceSpread

        Reads the summarized spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_project_resource_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadProjectResourceSpread

        Reads the summarized spreads of the specified Project Resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_resource_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_project_resource_spread_serialize(
        self,
        spread_field,
        project_object_id,
        resource_object_id,
        period_type,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_object_id is not None:
            
            _query_params.append(('ProjectObjectId', project_object_id))
            
        if resource_object_id is not None:
            
            _query_params.append(('ResourceObjectId', resource_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/projectResourceSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_project_role_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadProjectRoleSpreadResponse]:
        """ReadProjectRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified projects.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_role_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_project_role_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadProjectRoleSpreadResponse]]:
        """ReadProjectRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified projects.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_role_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_project_role_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        project_object_id: Annotated[Optional[StrictStr], Field(description="ProjectObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadProjectRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified projects.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param project_object_id: ProjectObjectId's to load
        :type project_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_role_spread_serialize(
            spread_field=spread_field,
            project_object_id=project_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_project_role_spread_serialize(
        self,
        spread_field,
        project_object_id,
        role_object_id,
        period_type,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_object_id is not None:
            
            _query_params.append(('ProjectObjectId', project_object_id))
            
        if role_object_id is not None:
            
            _query_params.append(('RoleObjectId', role_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/projectRoleSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_project_spread(
        self,
        project_object_id: Annotated[StrictStr, Field(description="ProjectObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadProjectSpreadResponse]:
        """ReadProjectSpread

        Reads the summarized spreads for the specified projects.

        :param project_object_id: ProjectObjectId's to load (required)
        :type project_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_spread_serialize(
            project_object_id=project_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_project_spread_with_http_info(
        self,
        project_object_id: Annotated[StrictStr, Field(description="ProjectObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadProjectSpreadResponse]]:
        """ReadProjectSpread

        Reads the summarized spreads for the specified projects.

        :param project_object_id: ProjectObjectId's to load (required)
        :type project_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_spread_serialize(
            project_object_id=project_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_project_spread_without_preload_content(
        self,
        project_object_id: Annotated[StrictStr, Field(description="ProjectObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadProjectSpread

        Reads the summarized spreads for the specified projects.

        :param project_object_id: ProjectObjectId's to load (required)
        :type project_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_project_spread_serialize(
            project_object_id=project_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadProjectSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_project_spread_serialize(
        self,
        project_object_id,
        period_type,
        spread_field,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if project_object_id is not None:
            
            _query_params.append(('ProjectObjectId', project_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/projectSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_resource_assignment_spread(
        self,
        resource_assignment_object_id: Annotated[StrictStr, Field(description="ResourceAssignmentObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadResourceAssignmentSpreadResponse]:
        """ReadResourceAssignmentSpread

        Reads the live resource assignment spread data from the specified resource assignment.

        :param resource_assignment_object_id: ResourceAssignmentObjectId's to load (required)
        :type resource_assignment_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_resource_assignment_spread_serialize(
            resource_assignment_object_id=resource_assignment_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadResourceAssignmentSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_resource_assignment_spread_with_http_info(
        self,
        resource_assignment_object_id: Annotated[StrictStr, Field(description="ResourceAssignmentObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadResourceAssignmentSpreadResponse]]:
        """ReadResourceAssignmentSpread

        Reads the live resource assignment spread data from the specified resource assignment.

        :param resource_assignment_object_id: ResourceAssignmentObjectId's to load (required)
        :type resource_assignment_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_resource_assignment_spread_serialize(
            resource_assignment_object_id=resource_assignment_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadResourceAssignmentSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_resource_assignment_spread_without_preload_content(
        self,
        resource_assignment_object_id: Annotated[StrictStr, Field(description="ResourceAssignmentObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadResourceAssignmentSpread

        Reads the live resource assignment spread data from the specified resource assignment.

        :param resource_assignment_object_id: ResourceAssignmentObjectId's to load (required)
        :type resource_assignment_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_resource_assignment_spread_serialize(
            resource_assignment_object_id=resource_assignment_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadResourceAssignmentSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_resource_assignment_spread_serialize(
        self,
        resource_assignment_object_id,
        period_type,
        spread_field,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if resource_assignment_object_id is not None:
            
            _query_params.append(('ResourceAssignmentObjectId', resource_assignment_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/resourceAssignmentSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_wbs_expense_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        expense_category_object_id: Annotated[Optional[StrictStr], Field(description="ExpenseCategoryObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadWBSExpenseSpreadResponse]:
        """ReadWBSExpenseSpread

        Reads the summarized WBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param expense_category_object_id: ExpenseCategoryObjectId's to load
        :type expense_category_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_expense_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            expense_category_object_id=expense_category_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_wbs_expense_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        expense_category_object_id: Annotated[Optional[StrictStr], Field(description="ExpenseCategoryObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadWBSExpenseSpreadResponse]]:
        """ReadWBSExpenseSpread

        Reads the summarized WBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param expense_category_object_id: ExpenseCategoryObjectId's to load
        :type expense_category_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_expense_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            expense_category_object_id=expense_category_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_wbs_expense_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        expense_category_object_id: Annotated[Optional[StrictStr], Field(description="ExpenseCategoryObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadWBSExpenseSpread

        Reads the summarized WBS spreads of the specified project resources

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param expense_category_object_id: ExpenseCategoryObjectId's to load
        :type expense_category_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_expense_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            expense_category_object_id=expense_category_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSExpenseSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_wbs_expense_spread_serialize(
        self,
        spread_field,
        wbs_object_id,
        expense_category_object_id,
        period_type,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wbs_object_id is not None:
            
            _query_params.append(('WBSObjectId', wbs_object_id))
            
        if expense_category_object_id is not None:
            
            _query_params.append(('ExpenseCategoryObjectId', expense_category_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/wbsExpenseSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_wbs_resource_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadWBSResourceSpreadResponse]:
        """ReadWBSResourceSpread

        Reads the summarized spreads of the Resources for the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_resource_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_wbs_resource_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadWBSResourceSpreadResponse]]:
        """ReadWBSResourceSpread

        Reads the summarized spreads of the Resources for the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_resource_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_wbs_resource_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        resource_object_id: Annotated[Optional[StrictStr], Field(description="ResourceObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadWBSResourceSpread

        Reads the summarized spreads of the Resources for the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param resource_object_id: ResourceObjectId's to load
        :type resource_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_resource_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            resource_object_id=resource_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSResourceSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_wbs_resource_spread_serialize(
        self,
        spread_field,
        wbs_object_id,
        resource_object_id,
        period_type,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wbs_object_id is not None:
            
            _query_params.append(('WBSObjectId', wbs_object_id))
            
        if resource_object_id is not None:
            
            _query_params.append(('ResourceObjectId', resource_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/wbsResourceSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_wbs_role_spread(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadWBSRoleSpreadResponse]:
        """ReadWBSRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_role_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_wbs_role_spread_with_http_info(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadWBSRoleSpreadResponse]]:
        """ReadWBSRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_role_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_wbs_role_spread_without_preload_content(
        self,
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        wbs_object_id: Annotated[Optional[StrictStr], Field(description="WBSObjectId's to load")] = None,
        role_object_id: Annotated[Optional[StrictStr], Field(description="RoleObjectId's to load")] = None,
        period_type: Annotated[Optional[StrictStr], Field(description="PeriodType to load")] = None,
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadWBSRoleSpread

        Reads the spreads of the specified role assignments to the activities from the specified WBS.

        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param wbs_object_id: WBSObjectId's to load
        :type wbs_object_id: str
        :param role_object_id: RoleObjectId's to load
        :type role_object_id: str
        :param period_type: PeriodType to load
        :type period_type: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_role_spread_serialize(
            spread_field=spread_field,
            wbs_object_id=wbs_object_id,
            role_object_id=role_object_id,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSRoleSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_wbs_role_spread_serialize(
        self,
        spread_field,
        wbs_object_id,
        role_object_id,
        period_type,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wbs_object_id is not None:
            
            _query_params.append(('WBSObjectId', wbs_object_id))
            
        if role_object_id is not None:
            
            _query_params.append(('RoleObjectId', role_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/wbsRoleSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def read_wbs_spread(
        self,
        wbs_object_id: Annotated[StrictStr, Field(description="WBSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ReadWBSSpreadResponse]:
        """ReadWBSSpread

        Reads the summarized WBS spread data for the specified WBS spread.

        :param wbs_object_id: WBSObjectId's to load (required)
        :type wbs_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_spread_serialize(
            wbs_object_id=wbs_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def read_wbs_spread_with_http_info(
        self,
        wbs_object_id: Annotated[StrictStr, Field(description="WBSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ReadWBSSpreadResponse]]:
        """ReadWBSSpread

        Reads the summarized WBS spread data for the specified WBS spread.

        :param wbs_object_id: WBSObjectId's to load (required)
        :type wbs_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_spread_serialize(
            wbs_object_id=wbs_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def read_wbs_spread_without_preload_content(
        self,
        wbs_object_id: Annotated[StrictStr, Field(description="WBSObjectId's to load")],
        period_type: Annotated[StrictStr, Field(description="PeriodType to load")],
        spread_field: Annotated[StrictStr, Field(description="SpreadField's to load")],
        start_date: Annotated[Optional[StrictStr], Field(description="StartDate")] = None,
        end_date: Annotated[Optional[StrictStr], Field(description="EndDate")] = None,
        include_cumulative: Annotated[Optional[StrictStr], Field(description="IncludeCumulative to load : Supported values - true, false")] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ReadWBSSpread

        Reads the summarized WBS spread data for the specified WBS spread.

        :param wbs_object_id: WBSObjectId's to load (required)
        :type wbs_object_id: str
        :param period_type: PeriodType to load (required)
        :type period_type: str
        :param spread_field: SpreadField's to load (required)
        :type spread_field: str
        :param start_date: StartDate
        :type start_date: str
        :param end_date: EndDate
        :type end_date: str
        :param include_cumulative: IncludeCumulative to load : Supported values - true, false
        :type include_cumulative: str
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._read_wbs_spread_serialize(
            wbs_object_id=wbs_object_id,
            period_type=period_type,
            spread_field=spread_field,
            start_date=start_date,
            end_date=end_date,
            include_cumulative=include_cumulative,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ReadWBSSpreadResponse]",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _read_wbs_spread_serialize(
        self,
        wbs_object_id,
        period_type,
        spread_field,
        start_date,
        end_date,
        include_cumulative,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wbs_object_id is not None:
            
            _query_params.append(('WBSObjectId', wbs_object_id))
            
        if period_type is not None:
            
            _query_params.append(('PeriodType', period_type))
            
        if start_date is not None:
            
            _query_params.append(('StartDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('EndDate', end_date))
            
        if include_cumulative is not None:
            
            _query_params.append(('IncludeCumulative', include_cumulative))
            
        if spread_field is not None:
            
            _query_params.append(('SpreadField', spread_field))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/spread/wbsSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_resource_assignment_spread(
        self,
        update_resource_assignment_spread: Annotated[Dict[str, Any], Field(description="ResourceAssignmentSpread object.")],
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bool:
        """Update ResourceAssignmentSpread

        Send a request to this endpoint to update one or more ResourceAssignmentSpread. An application object will be created for each JSON object provided in the request body

        :param update_resource_assignment_spread: ResourceAssignmentSpread object. (required)
        :type update_resource_assignment_spread: UpdateResourceAssignmentSpread
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_resource_assignment_spread_serialize(
            update_resource_assignment_spread=update_resource_assignment_spread,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bool",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_resource_assignment_spread_with_http_info(
        self,
        update_resource_assignment_spread: Annotated[Dict[str, Any], Field(description="ResourceAssignmentSpread object.")],
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bool]:
        """Update ResourceAssignmentSpread

        Send a request to this endpoint to update one or more ResourceAssignmentSpread. An application object will be created for each JSON object provided in the request body

        :param update_resource_assignment_spread: ResourceAssignmentSpread object. (required)
        :type update_resource_assignment_spread: UpdateResourceAssignmentSpread
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_resource_assignment_spread_serialize(
            update_resource_assignment_spread=update_resource_assignment_spread,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bool",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_resource_assignment_spread_without_preload_content(
        self,
        update_resource_assignment_spread: Annotated[Dict[str, Any], Field(description="ResourceAssignmentSpread object.")],
        authorization: Annotated[Optional[StrictStr], Field(description="OAuth token")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update ResourceAssignmentSpread

        Send a request to this endpoint to update one or more ResourceAssignmentSpread. An application object will be created for each JSON object provided in the request body

        :param update_resource_assignment_spread: ResourceAssignmentSpread object. (required)
        :type update_resource_assignment_spread: UpdateResourceAssignmentSpread
        :param authorization: OAuth token
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_resource_assignment_spread_serialize(
            update_resource_assignment_spread=update_resource_assignment_spread,
            authorization=authorization,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bool",
            '400': None,
            '401': None,
            '403': None,
            '404': None,
            '405': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_resource_assignment_spread_serialize(
        self,
        update_resource_assignment_spread,
        authorization,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        # process the form parameters
        # process the body parameter
        if update_resource_assignment_spread is not None:
            _body_params = update_resource_assignment_spread


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/spread/resourceAssignmentSpread',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


