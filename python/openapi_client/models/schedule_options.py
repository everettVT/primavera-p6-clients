# coding: utf-8

"""
    P6 EPPM Rest API

    The Primavera P6 Enterprise Project Portfolio Management (P6 EPPM) API is a flexible interface to P6 EPPM functionality based on the Representational State Transfer (REST) architectural style. Clients can use HTTP enabled technologies to interact with the API and access application features. For example, you can write programs in Javascript, Java, and other languages to create users, view a list of users, update a user's status, or update user details.

    The version of the OpenAPI document: 2022.12.12
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ScheduleOptions(BaseModel):
    """
    ScheduleOptions Entity
    """ # noqa: E501
    calculate_float_based_on_finish_date: Optional[StrictBool] = Field(default=None, description="The flag that indicates how each activity's float will be calculated with respect to other projects in the scheduling batch. This setting only has an effect when scheduling multiple projects at the same time. If true, each activity's float is calculated based on its project's ScheduledFinishDate. If false, then each activity's float is calculated based on the latest ScheduledFinishDate of all of the projects in the scheduling batch.", alias="CalculateFloatBasedOnFinishDate")
    compute_total_float_type: Optional[StrictStr] = Field(default=None, description="The method for calculating total float for all activities. Start Float is the difference between the early and late start dates (Start Float = Late Start - Early Start); Finish Float is the difference between the early and late finish dates (Finish Float = Late Finish - Early Finish); and Smallest of Start Float and Finish Float is the most critical float value.", alias="ComputeTotalFloatType")
    create_date: Optional[datetime] = Field(default=None, description="The date this schedule option was created.", alias="CreateDate")
    create_user: Optional[StrictStr] = Field(default=None, description="The name of the user that created this schedule option.", alias="CreateUser")
    critical_activity_float_threshold: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The maximum float time for activities before they are marked critical.", alias="CriticalActivityFloatThreshold")
    critical_activity_path_type: Optional[StrictStr] = Field(default=None, description="The critical path type, which indicates how critical path activities are identified for the project, based on either 'Critical Float' or 'Longest Path'.", alias="CriticalActivityPathType")
    external_project_priority_limit: Optional[StrictInt] = Field(default=None, alias="ExternalProjectPriorityLimit")
    ignore_other_project_relationships: Optional[StrictBool] = Field(default=None, description="The option used by the scheduler for treating activity relationships between projects when scheduling.", alias="IgnoreOtherProjectRelationships")
    include_external_res_ass: Optional[StrictBool] = Field(default=None, alias="IncludeExternalResAss")
    last_update_date: Optional[datetime] = Field(default=None, description="The date this schedule option was last updated.", alias="LastUpdateDate")
    last_update_user: Optional[StrictStr] = Field(default=None, description="The name of the user that last updated this schedule option.", alias="LastUpdateUser")
    level_all_resources: Optional[StrictBool] = Field(default=None, alias="LevelAllResources")
    level_within_float: Optional[StrictBool] = Field(default=None, alias="LevelWithinFloat")
    make_open_ended_activities_critical: Optional[StrictBool] = Field(default=None, description="The option used by the scheduler for automatically leveling resources when scheduling projects.", alias="MakeOpenEndedActivitiesCritical")
    maximum_multiple_float_paths: Optional[StrictInt] = Field(default=None, description="The number of critical float paths to calculate. For example, if you set the field to five, the module calculates the five most critical float paths ending with the activity you selected. The module ranks each float path from most critical to least critical, and stores the value for each activity in the Float Path field. For example, if you calculate five float paths, the module will store a value of one in the Float Path field for each activity in the most critical float path; the module will store a value of five for each activity in the least critical float path. Note: To view the critical float paths after you schedule the project, group activities in the Activity Table by Float Path and sort by Float Path Order. A Float Path value of one indicates that those activities are part of the most critical float path. The Float Path Order value indicates the order in which the activities were processed.", alias="MaximumMultipleFloatPaths")
    min_float_to_preserve: Optional[StrictInt] = Field(default=None, alias="MinFloatToPreserve")
    multiple_float_paths_enabled: Optional[StrictBool] = Field(default=None, description="The Boolean value that indicates whether multiple critical float paths (sequences of activities) should be calculated in the project schedule.", alias="MultipleFloatPathsEnabled")
    multiple_float_paths_ending_activity_object_id: Optional[StrictInt] = Field(default=None, description="The activity in the WBS that you want to represent the end of the float paths. Typically, this will be a milestone activity or some other significant activity that has a start date or end date that cannot change. Note: if a value is not assigned, the module will choose an activity based on MultipleFloatPathsUseTotalFloat. If you are calculating multiple paths using Free Float, the module will choose the open-ended activity with the most critical Free Float. If you are calculating multiple paths using Total Float, the module will calculate the Total Float for all activity relationships, then choose the activity with the most critical Relationship Total Float.", alias="MultipleFloatPathsEndingActivityObjectId")
    multiple_float_paths_ending_activity_short_name: Optional[StrictStr] = Field(default=None, alias="MultipleFloatPathsEndingActivityShortName")
    multiple_float_paths_use_total_float: Optional[StrictBool] = Field(default=None, description="The Boolean value that decides whether or not to use total float in multiple float path calculations.If True, then based on the activity you want the paths to end on, the module determines which predecessor activity has the most critical Relationship Total Float on the backward pass. The module repeats this process until an activity is reached that has no relationship. The module begins the forward pass from this activity and determines which successor activity has the most critical Relationship Successor Total Float. The module repeats this process until an activity is reached that has no relationship. These activities represent the most critical float path. The process begins again until the remaining sub-critical paths are calculated.If False, then critical float paths are defined based on longest path. The most critical path will be identical to the critical path that is derived when you choose to define critical activities as Longest Path in the General tab. In a multicalendar project, the longest path is calculated by identifying the activities that have an early finish equal to the latest calculated early finish for the project and tracing all driving relationships for those activities back to the project start date. After the most critical path is identified, the module will calculate the remaining sub-critical paths.", alias="MultipleFloatPathsUseTotalFloat")
    out_of_sequence_schedule_type: Optional[StrictStr] = Field(default=None, description="The type of logic used to schedule the progressed activities: 'Retained Logic', 'Progress Override', or 'Actual Dates'.", alias="OutOfSequenceScheduleType")
    over_allocation_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="OverAllocationPercentage")
    preserve_scheduled_early_and_late_dates: Optional[StrictBool] = Field(default=None, alias="PreserveScheduledEarlyAndLateDates")
    priority_list: Optional[StrictStr] = Field(default=None, alias="PriorityList")
    project_id: Optional[StrictStr] = Field(default=None, description="The short code that uniquely identifies the project.", alias="ProjectId")
    project_object_id: Optional[StrictInt] = Field(default=None, description="The unique ID of the associated project.", alias="ProjectObjectId")
    relationship_lag_calendar: Optional[StrictStr] = Field(default=None, description="The calendar used to calculate the lag between predecessors and successors for all activities. Valid values are 'Predecessor Activity Calendar', 'Successor Activity Calendar', '24 Hour Calendar', and 'Project Default Calendar'. If you do not select a calendar, the successor activity calendar is used.", alias="RelationshipLagCalendar")
    resource_list: Optional[StrictStr] = Field(default=None, alias="ResourceList")
    start_to_start_lag_calculation_type: Optional[StrictBool] = Field(default=None, description="he method used to calculate lag when a start-to-start relationship exists and the predecessor starts out of sequence. Actual Start sets the successor's start according to the time elapsed from the predecessor's actual start (the successor's start date is the data date plus any remaining lag). Early Start sets the successor's start according to the amount of work that the predecessor activity accomplishes (the expired lag is calculated as the number of work periods between the actual start and the data date, and the successor's start date is the predecessor's internal early start plus any remaining lag).", alias="StartToStartLagCalculationType")
    use_expected_finish_dates: Optional[StrictBool] = Field(default=None, description="The option used for setting activity finish dates as the expected finish dates when scheduling projects.", alias="UseExpectedFinishDates")
    user_name: Optional[StrictStr] = Field(default=None, description="The user's login name.", alias="UserName")
    user_object_id: Optional[StrictInt] = Field(default=None, description="The unique ID of the associated user.", alias="UserObjectId")
    __properties: ClassVar[List[str]] = ["CalculateFloatBasedOnFinishDate", "ComputeTotalFloatType", "CreateDate", "CreateUser", "CriticalActivityFloatThreshold", "CriticalActivityPathType", "ExternalProjectPriorityLimit", "IgnoreOtherProjectRelationships", "IncludeExternalResAss", "LastUpdateDate", "LastUpdateUser", "LevelAllResources", "LevelWithinFloat", "MakeOpenEndedActivitiesCritical", "MaximumMultipleFloatPaths", "MinFloatToPreserve", "MultipleFloatPathsEnabled", "MultipleFloatPathsEndingActivityObjectId", "MultipleFloatPathsEndingActivityShortName", "MultipleFloatPathsUseTotalFloat", "OutOfSequenceScheduleType", "OverAllocationPercentage", "PreserveScheduledEarlyAndLateDates", "PriorityList", "ProjectId", "ProjectObjectId", "RelationshipLagCalendar", "ResourceList", "StartToStartLagCalculationType", "UseExpectedFinishDates", "UserName", "UserObjectId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ScheduleOptions from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ScheduleOptions from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "CalculateFloatBasedOnFinishDate": obj.get("CalculateFloatBasedOnFinishDate"),
            "ComputeTotalFloatType": obj.get("ComputeTotalFloatType"),
            "CreateDate": obj.get("CreateDate"),
            "CreateUser": obj.get("CreateUser"),
            "CriticalActivityFloatThreshold": obj.get("CriticalActivityFloatThreshold"),
            "CriticalActivityPathType": obj.get("CriticalActivityPathType"),
            "ExternalProjectPriorityLimit": obj.get("ExternalProjectPriorityLimit"),
            "IgnoreOtherProjectRelationships": obj.get("IgnoreOtherProjectRelationships"),
            "IncludeExternalResAss": obj.get("IncludeExternalResAss"),
            "LastUpdateDate": obj.get("LastUpdateDate"),
            "LastUpdateUser": obj.get("LastUpdateUser"),
            "LevelAllResources": obj.get("LevelAllResources"),
            "LevelWithinFloat": obj.get("LevelWithinFloat"),
            "MakeOpenEndedActivitiesCritical": obj.get("MakeOpenEndedActivitiesCritical"),
            "MaximumMultipleFloatPaths": obj.get("MaximumMultipleFloatPaths"),
            "MinFloatToPreserve": obj.get("MinFloatToPreserve"),
            "MultipleFloatPathsEnabled": obj.get("MultipleFloatPathsEnabled"),
            "MultipleFloatPathsEndingActivityObjectId": obj.get("MultipleFloatPathsEndingActivityObjectId"),
            "MultipleFloatPathsEndingActivityShortName": obj.get("MultipleFloatPathsEndingActivityShortName"),
            "MultipleFloatPathsUseTotalFloat": obj.get("MultipleFloatPathsUseTotalFloat"),
            "OutOfSequenceScheduleType": obj.get("OutOfSequenceScheduleType"),
            "OverAllocationPercentage": obj.get("OverAllocationPercentage"),
            "PreserveScheduledEarlyAndLateDates": obj.get("PreserveScheduledEarlyAndLateDates"),
            "PriorityList": obj.get("PriorityList"),
            "ProjectId": obj.get("ProjectId"),
            "ProjectObjectId": obj.get("ProjectObjectId"),
            "RelationshipLagCalendar": obj.get("RelationshipLagCalendar"),
            "ResourceList": obj.get("ResourceList"),
            "StartToStartLagCalculationType": obj.get("StartToStartLagCalculationType"),
            "UseExpectedFinishDates": obj.get("UseExpectedFinishDates"),
            "UserName": obj.get("UserName"),
            "UserObjectId": obj.get("UserObjectId")
        })
        return _obj


